# 使用Makefile构建

本项目基于xv6出发构建。xv6基于UNIX v6衍生而来，作为教学用操作系统，其项目工程目录有着简单、迷你等特点，无论是从`.o`文件的生成还是最终目标文件的构建，都将被存放在原始的`kernel`以及`user`目录下。对于教学用操作系统来说，这样做无可厚非，同时可以降低同学们理解项目构建过程的门槛，更好地把握项目整体的结构，建立起整体系统的观念。

## 缺陷

然而，这样的构建不难看出充满着种种问题。一方面，各种类型文件混杂将会使得工程目录复杂化与臃肿化；另一方面，操作系统突出模块化的设计思想，若将所有代码放在同一目录下，必将导致模块代码之间难以难分，更甚者，可能存在同名冲突，无名可起的问题。此外，从开发维护的角度出发来看，这也极其不友好。

## 我的工作

### 目录结构

工程文件将被分目录存放：

```shell
.
├── bootloader #bootloader相关（主要为SBI）
│   └── rustsbi-qemu #qemu下的sbi
|	└── rustsbi-k210 #k210下的sbi
├── build #输出文件夹
|   └── objs #下级目录结构同src
|   └── user_prog #用户程序目录
├── doc #文档相关
├── include #公共头文件
│   └── kernel #内核相关头文件
├── script #辅助脚本文件
└── src #代码目录
    ├── kernel #内核目录（平台无关代码）
    │   ├── asm #.S
    │   ├── fs #文件系统
    │   ├── lib #库文件
    │   └── mm #内存管理
    |   └── ...
    ├── platform #平台相关代码
    │   ├── k210
    │   └── qemu
    │       ├── driver #驱动相关
    │       └── include #平台相关头文件（memlayout.h等）
    └── user
        ├── include #用户头文件
        └── lib #用户库
        └── ...
```

### 递归构建

Makefile被编写为递归目录构建，这意味着每个src下的子目录都将含有Makefile，虽然这样可能会导致Makefile编写上的一些*冗余*，但是极大地便于后期子目录的编译**定制化**。比如说，未来可能我想在用户目录下构建自己的一个[shell程序]([yztz/shell: a shell (github.com)](https://github.com/yztz/shell))，但是这个shell不是一个单文件的工程，可能需要许多模块的链接，我可能需要为这个项目的构建单独写一个Makefile，如果没有递归构建的策略，那么将会导致项目构建变得异常复杂！

每个文件夹下的Makefile将只会编译当前的文件夹下的源文件（不会去编译子目录或父目录中的源文件！），同时将目标`.o`文件输出到与`/path/to/proj/src`拥有相同目录结构的`/path/to/ptoj/build/objs`目录下，这样做的目的在于结构化输出文件，与源文件形成一一对应的关系，便于查看以及维护。

递归构建遵循**子目录优先构建**的原则，也就是说，子目录将总会被优先编译，此后再编译当前目录下的源文件。这样的原则利于解决上述「只编译当前目录源文件」而可能产生的依赖问题。