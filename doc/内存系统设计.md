# 页回收



# 测试

## 单核单进程

**测试用例**

先是brk 2000页，往里面写入此页的虚拟地址，然后再读取这2000页中的内容并且输出。

**过程**

先是不停的brk，内存满了以后，通过swap out换出页，把物理页继续使用，具体过程是先添加到swap cache中，然后从中取出写会；

## 单核双进程



## 多核

# debug 记录

暑假比赛的时候做的，时间久远了，记得当时还有bug，先把swap修一下。

16进制输出变量：

<img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118181120844.png" alt="image-20230118181120844" style="zoom: 67%;" />

16进制展示变量：

```
-exec set output-radix 16
```

<img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118181437946.png" alt="image-20230118181437946" style="zoom:67%;" />

1. 发现`swap` 没开（config.h）

2. <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118184620382.png" alt="image-20230118184620382" style="zoom:67%;" />

   报这个bug的原因，为了节省时间，每回没有重新制作`fs.img`，导致了`swap`文件在内存中的大小小于在外存中的大小，边界检查报错。

3. 卡着不动，原来卡在`retry`这里了。

   <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118214525952.png" alt="image-20230118214525952" style="zoom: 50%;" />

4. 发现了页被`locked`，导致了不能被回收，在`shrink_list`里面。

5. ![image-20230118232724274](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118232724274.png)
   找到问题了，页的`flags`在这里被设置为`locked`，但是没有`clear`，从而在导致了上面4的问题？
   在回收`pagecache`的时候，函数`remove_put_pages_in_pagecache`居然回收用作`swap`的文件的页，是否正确？
   按理说在`shrink_list` 添加到`swap`之后，就在这里页被回收并且释放掉了，怎么在上面的函数中，`swap` 文件中还有页？？
   找到了`swap`文件中页数增加的原因了，是因为`swap_in_page`的缘故。
   ![image-20230119213733377](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230119213733377.png)
   
   上图中没有成功
   ![image-20230120005923559](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120005923559.png)
   运行成功。
   
   
   
6. ![image-20230119001539276](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230119001539276.png)
   8月9日的一次save提交中在加入和删除pagecache中添加了增减页？莫名奇妙。

7. 























<p align="right">朱洋洋<br/>2023/1/18</p>