# 页回收



# 测试

## 单核单进程

**测试用例**

先是brk 2000页，往里面写入此页的虚拟地址，然后再读取这2000页中的内容并且输出。

**过程**

先是不停的brk，内存满了以后，通过swap out换出页，把物理页继续使用，具体过程是先添加到swap cache中，然后从中取出写回，这个页就释放了；

然后读取这些页，swap in，添加到swap cache中，然后和虚拟地址建立map。

## 单核双进程



## 多核

# debug 记录

暑假比赛的时候做的，时间久远了，记得当时还有bug，先把swap修一下。

16进制输出变量：

<img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118181120844.png" alt="image-20230118181120844" style="zoom: 67%;" />

16进制展示变量：

```
-exec set output-radix 16
```

<img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118181437946.png" alt="image-20230118181437946" style="zoom:67%;" />

1. 发现`swap` 没开（config.h）

2. <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118184620382.png" alt="image-20230118184620382" style="zoom:67%;" />

   报这个bug的原因，为了节省时间，每回没有重新制作`fs.img`，导致了`swap`文件在内存中的大小小于在外存中的大小，边界检查报错。

3. 卡着不动，原来卡在`retry`这里了。

   <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118214525952.png" alt="image-20230118214525952" style="zoom: 50%;" />

4. 发现了页被`locked`，导致了不能被回收，在`shrink_list`里面。

5. ![image-20230118232724274](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230118232724274.png)
   找到问题了，页的`flags`在这里被设置为`locked`，但是没有`clear`，从而在导致了上面4的问题？
   在回收`pagecache`的时候，函数`remove_put_pages_in_pagecache`居然回收用作`swap`的文件的页，是否正确？
   按理说在`shrink_list` 添加到`swap`之后，就在这里页被回收并且释放掉了，怎么在上面的函数中，`swap` 文件中还有页？？
   找到了`swap`文件中页数增加的原因了，是因为`swap_in_page`的缘故。
   ![image-20230119213733377](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230119213733377.png)

   上图中没有成功
   ![image-20230120005923559](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120005923559.png)
   运行成功。

   

6. ![image-20230119001539276](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230119001539276.png)
   8月9日的一次save提交中在加入和删除pagecache中添加了增减页？莫名奇妙。

7. 两个进程有bug，怀疑是两进程同时对一个swap文件操作引入的？
   <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120100841070.png" alt="image-20230120100841070" style="zoom:50%;" />
   父子进程随机挂掉一个，读出来奇怪的数字。

   总共有936页，每个进程分配400页不会挂掉，看来就是swap导致的。
   还有一个问题，单个进程的开始地址是3000，但是这里确是从4000开始的。

   <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120122136859.png" alt="image-20230120122136859" style="zoom: 67%;" />
   加个for卡住，打印出来是3000；不加，打印出来是4000.
   在gdb中调用状态函数打印信息。

   ```
   call func()
   ```

   这些调试技巧很有用。<img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120141712263.png" alt="image-20230120141712263" style="zoom:50%;" />
   多进程的vma打印函数，堆是从0x4000开始的。
   <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120152605775.png" alt="image-20230120152605775" style="zoom:67%;" />
   有时候多进程会成功，但是出错的时候，从中读出的值似乎是固定的。
   <img src="https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120153559937.png" alt="image-20230120153559937" style="zoom:67%;" />
   新的发现，随机会出错，但是出错之后，后面还有可能正确。似乎有什么规律，每隔32个输出，就会出现一次panic？

   ![image-20230120155743475](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120155743475.png)
   把页改为1000，处罚panic，接下来检测panic，锁为什么设置了两次。
   ![image-20230120161723530](https://raw.githubusercontent.com/DavidZyy/img_bed_2/main/images/image-20230120161723530.png)
   又有一个bug，进程跑完后释放出错？























<p align="right">朱洋洋<br/>2023/1/18</p>